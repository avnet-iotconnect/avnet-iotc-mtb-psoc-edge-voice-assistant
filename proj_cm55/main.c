/****************************************************************************
* File Name        : main.c
*
* Description      : This source file contains the main routine for CM55 CPU
*
* Related Document : See README.md
*
********************************************************************************
* Copyright 2025, Cypress Semiconductor Corporation (an Infineon company) or
* an affiliate of Cypress Semiconductor Corporation.  All rights reserved.
*
* This software, including source code, documentation and related
* materials ("Software") is owned by Cypress Semiconductor Corporation
* or one of its affiliates ("Cypress") and is protected by and subject to
* worldwide patent protection (United States and foreign),
* United States copyright laws and international treaty provisions.
* Therefore, you may use this Software only as provided in the license
* agreement accompanying the software package from which you
* obtained this Software ("EULA").
* If no EULA applies, Cypress hereby grants you a personal, non-exclusive,
* non-transferable license to copy, modify, and compile the Software
* source code solely for use in connection with Cypress's
* integrated circuit products.  Any reproduction, modification, translation,
* compilation, or representation of this Software except as specified
* above is prohibited without the express written permission of Cypress.
*
* Disclaimer: THIS SOFTWARE IS PROVIDED AS-IS, WITH NO WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, NONINFRINGEMENT, IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. Cypress
* reserves the right to make changes to the Software without notice. Cypress
* does not assume any liability arising out of the application or use of the
* Software or any product or circuit described in the Software. Cypress does
* not authorize its products for use in any products where a malfunction or
* failure of the Cypress product may reasonably be expected to result in
* significant property damage, injury or death ("High Risk Product"). By
* including Cypress's product in a High Risk Product, the manufacturer
* of such system or application assumes all risk of such use and in doing
* so agrees to indemnify Cypress against all liability.
*******************************************************************************/

#include "cybsp.h"

/* RTOS includes */
#include "FreeRTOS.h"
#include "task.h"
#include "cyabs_rtos.h"

/* Peripherals related includes */
#include "pdm_mic.h"
#include "led_pwm.h"
#include "retarget_io_init.h"

/* Application related includes */
#include "voice_assistant.h"
#include "profiler.h"

#ifdef USE_AUDIO_ENHANCEMENT
#include "audio_enhancement.h"
#endif

/* Include the headers generated by the DEEPCRAFT Voice-Assistant cloud tool*/
#include MTB_WWD_NLU_APP_HEADER(PROJECT_PREFIX)
#include MTB_WWD_NLU_CONFIG_HEADER(PROJECT_PREFIX)

/*****************************************************************************
 * Macros
 *****************************************************************************/
#define VOICE_ASSISTANT_TASK_NAME               ("voice-assistant task")
#define VOICE_ASSISTANT_TASK_STACK_SIZE         (10 * 1024)
#define VOICE_ASSISTANT_TASK_PRIORITY           (CY_RTOS_PRIORITY_NORMAL)

/* Enabling or disabling a MCWDT requires a wait time of upto 2 CLK_LF cycles  
 * to come into effect. This wait time value will depend on the actual CLK_LF  
 * frequency set by the BSP.
 */
#define LPTIMER_1_WAIT_TIME_USEC                (62U)

/* Define the LPTimer interrupt priority number. '1' implies highest priority. 
 */
#define APP_LPTIMER_INTERRUPT_PRIORITY          (1U)

/* This is the maximum size of the command string that can be detected by the 
 * voice assistant. 
 */
#define COMMAND_STRING_SIZE                     (250U) 

/* Debounce counter for button presses (multiply by 10 ms) */
#define BUTTON_DEBOUNCE_COUNT                   (10U)

/* Number of audio channels sampled from microphones and processed */
#define NUM_AUDIO_CHANNELS                      (1U)

/* How often to print the MCPS (multiply by 10 ms) */
#define PRINT_MCPS_COUNT                        (100u)    

/* Uncomment to print MCPS (Voice-Assistant only) */
//#define SHOW_MCPS

/* Choose one of the following options to run the voice-assistant: 
 * VA_MODE_WW_SINGLE_CMD : For every wake word, a single command is detected
 * VA_MODE_WW_MULTI_CMD  : For every wake word, multiple commands can be detected
 * VA_MODE_WW_ONLY       : Only wake word detection is performed
 * VA_MODE_CMD_ONLY      : Only command detection is performed
 */
#define RUNNING_MODE            (VA_MODE_WW_SINGLE_CMD) 

/*****************************************************************************
 * Variables
 *****************************************************************************/
/* For the Tickless idle configuration*/
static mtb_hal_lptimer_t lptimer_obj;

/* Breathing counter for the kit's blue LED */
static uint8_t breathing_counter;

/* Required by the audio-voice-core to build */
uint8_t bf_coeffs[1];
uint32_t bf_coeffs_total_len;

#ifdef SHOW_MCPS
/* Variables used to print and calculate MCPS */
uint32_t show_count = 0;
uint32_t cpu_cycle_sum = 0;
#endif
/*******************************************************************************
* Function Name: lptimer_interrupt_handler
********************************************************************************
* Summary:
* Interrupt handler function for LPTimer instance.
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
static void lptimer_interrupt_handler(void)
{
    mtb_hal_lptimer_process_interrupt(&lptimer_obj);
}

/*******************************************************************************
* Function Name: setup_tickless_idle_timer
********************************************************************************
* Summary:
* 1. This function first configures and initializes an interrupt for LPTimer.
* 2. Then it initializes the LPTimer HAL object to be used in the RTOS 
*    tickless idle mode implementation to allow the device enter deep sleep 
*    when idle task runs. LPTIMER_1 instance is configured for CM55 CPU.
* 3. It then passes the LPTimer object to abstraction RTOS library that 
*    implements tickless idle mode
*
* Parameters:
*  void
*
* Return:
*  void
*
*******************************************************************************/
static void setup_tickless_idle_timer(void)
{
    /* Interrupt configuration structure for LPTimer */
    cy_stc_sysint_t lptimer_intr_cfg =
    {
        .intrSrc = CYBSP_CM55_LPTIMER_1_IRQ,
        .intrPriority = APP_LPTIMER_INTERRUPT_PRIORITY
    };

    /* Initialize the LPTimer interrupt and specify the interrupt handler. */
    cy_en_sysint_status_t interrupt_init_status = 
                                    Cy_SysInt_Init(&lptimer_intr_cfg, 
                                                    lptimer_interrupt_handler);
    
    /* LPTimer interrupt initialization failed. Stop program execution. */
    if(CY_SYSINT_SUCCESS != interrupt_init_status)
    {
        handle_error();
    }

    /* Enable NVIC interrupt. */
    NVIC_EnableIRQ(lptimer_intr_cfg.intrSrc);

    /* Initialize the MCWDT block */
    cy_en_mcwdt_status_t mcwdt_init_status = 
                                    Cy_MCWDT_Init(CYBSP_CM55_LPTIMER_1_HW, 
                                                &CYBSP_CM55_LPTIMER_1_config);

    /* MCWDT initialization failed. Stop program execution. */
    if(CY_MCWDT_SUCCESS != mcwdt_init_status)
    {
        handle_error();
    }
  
    /* Enable MCWDT instance */
    Cy_MCWDT_Enable(CYBSP_CM55_LPTIMER_1_HW,
                    CY_MCWDT_CTR_Msk, 
                    LPTIMER_1_WAIT_TIME_USEC);

    /* Setup LPTimer using the HAL object and desired configuration as defined
     * in the device configurator. */
    cy_rslt_t result = mtb_hal_lptimer_setup(&lptimer_obj, 
                                            &CYBSP_CM55_LPTIMER_1_hal_config);
    
    /* LPTimer setup failed. Stop program execution. */
    if(CY_RSLT_SUCCESS != result)
    {
        handle_error();
    }

    /* Pass the LPTimer object to abstraction RTOS library that implements 
     * tickless idle mode 
     */
    cyabs_rtos_set_lptimer(&lptimer_obj);
}

#ifdef USE_LED_DEMO
/*******************************************************************************
 * Function Name: led_demo
 *******************************************************************************
 * Summary:
 * Update the LED state and brightness based on the intent detected.
 *  
 * Parameters:
 *  intent: detected intent index
 *  brightness: LED brightness level (0-100)
  *
 * Return:
 *  void
 *
 *******************************************************************************/
static void led_demo(int intent, uint8_t brightness)
{
    /* LED PWM driver is used to control the LED brightness and state. */
    switch (intent)
    {
        case LED_DEMO_INTENT_TurnOnLight:
            led_pwm_on(LED_PWM_GREEN_LED);
            break;
        case LED_DEMO_INTENT_TurnOffLight:
            led_pwm_off(LED_PWM_GREEN_LED);
            break;
        case LED_DEMO_INTENT_IncreaseBrightness:
            led_pwm_set_brightness(LED_PWM_GREEN_LED, LED_PWM_MAX_BRIGHTNESS);
            break;
        case LED_DEMO_INTENT_DecreaseBrightness:
            led_pwm_set_brightness(LED_PWM_GREEN_LED, LED_PWM_MIN_BRIGHTNESS);
            break;
        case LED_DEMO_INTENT_SetBrightness:
            led_pwm_set_brightness(LED_PWM_GREEN_LED, brightness);
            break;
        case LED_DEMO_INTENT_ToggleLight:
            led_pwm_toggle(LED_PWM_GREEN_LED);
            break;
        default:
            break;
    }
}
#endif


/*******************************************************************************
 * Function Name: check_button_pressed
 *******************************************************************************
 * Summary:
 * Check if the user button is pressed.
 *  
 * Parameters:
 *  
 * Return:
 *  Returns true if the button is pressed, false otherwise
 *
 *******************************************************************************/
static bool check_button_pressed(void)
{
    static uint32_t btn_count = 0;

    if (0 == Cy_GPIO_Read(CYBSP_USER_BTN1_PORT, CYBSP_USER_BTN1_NUM))
    {
        btn_count++;
    }
    else
    {
        btn_count = 0;
    }

    /* If the button is pressed for more than BUTTON_DEBOUNCE_COUNT, return true */
    if (btn_count > BUTTON_DEBOUNCE_COUNT)
    {
        btn_count = 0;
        return true;
    }
    return false;
}

#ifdef SHOW_MCPS
/*******************************************************************************
 * Function Name: print_mcps
 *******************************************************************************
 * Summary:
 * Prints the number of CPU cycles in Mega cycles per second (MCPS)
 *  
 * Parameters:
 *  
 * Return:
 *  void
 *
 *******************************************************************************/
static void print_mcps(void)
{
    cpu_cycle_sum += profiler_get_cycles();
    show_count++;
    if(show_count >= PRINT_MCPS_COUNT) 
    {
        printf("Profiler: %u MCPS\r\n", cpu_cycle_sum/1000000);
        show_count = 0;
        cpu_cycle_sum = 0;
    }
}
#endif

/*******************************************************************************
 * Function Name: print_voice_assistant_status
 *******************************************************************************
 * Summary:
 * Prints an error message if wake-word detection result is not successful. 
 * Or a detection message if wake-word is detected.
 * Also update the Green LED to indicate the voice assistant state.
 *  
 * Parameters:
 *  result: result of the voice-assistant operation
 *  event: state of the voice-assistant operation
 *  va_data: data detected from the voice-assistant operation
 *
 * Return:
 *  void
 *
 *******************************************************************************/
static void print_voice_assistant_status(cy_rslt_t result, va_event_t event, va_data_t *va_data)
{
    char command_text[COMMAND_STRING_SIZE] = {0};

    if (result == VA_RSLT_LICENSE_ERROR)
    {
        printf("ERROR! Voice Assistant license expired!\r\n");
        handle_error();
    }
    else if ( result != VA_RSLT_SUCCESS )
    {
        printf("Error! voice_assistant_process!! Error code=%d\r\n", result);
    }
    else
    {
        if ( event == VA_EVENT_WW_DETECTED )
        {
            if (RUNNING_MODE != VA_MODE_WW_ONLY)
            {
                breathing_counter = LED_PWM_MIN_BRIGHTNESS;
            }
            printf("Wake-word detected!\r\n");
        }
        else if ( event == VA_EVENT_CMD_TIMEOUT )
        {
            if (RUNNING_MODE != VA_MODE_CMD_ONLY)
            {
                breathing_counter = 0;
                printf("Command Timeout!\r\n");
            }
        }
        else if ( event == VA_EVENT_CMD_SILENCE_TIMEOUT )
        {
            if ((RUNNING_MODE != VA_MODE_WW_MULTI_CMD) && (RUNNING_MODE != VA_MODE_CMD_ONLY))
            {
                breathing_counter = 0;
                printf("Pre Silence Timeout!\r\n");
            }
        }
        else if ( event == VA_EVENT_CMD_DETECTED )
        {
            if (RUNNING_MODE == VA_MODE_WW_SINGLE_CMD)
            {
                breathing_counter = 0;
            }
            printf("Command detected: ");
            if (CY_RSLT_SUCCESS == voice_assistant_get_command(command_text))
            {
                printf("%s\r\n\r\n", command_text);
            }

            if (va_data == NULL)
            {
                return;
            }

            printf("Intent name: %s\r\n", MTB_NLU_INTENT_NAME_LIST(PROJECT_PREFIX)[va_data->intent_index] );

            if (va_data->num_var != 0)
            {
                printf("Variable values: ");
                for (int i = 0; i < va_data->num_var; i++)
                {
                    if (va_data->variable[i].unit_idx < 0)
                    {
                        printf("%s ", MTB_NLU_VARIABLE_PHRASE_LIST(PROJECT_PREFIX)[va_data->variable[i].value]);
                    }
                    else
                    {
                        printf("%d ", va_data->variable[i].value);
                    }
                }
                printf("\n\rVariable units : ");
                for (int i = 0; i < va_data->num_var; i++)
                {
                    if (va_data->variable[i].unit_idx < 0)
                    {
                        printf("---");
                    }
                    else
                    {
                        printf("%s", MTB_NLU_UNIT_PHRASE_LIST(PROJECT_PREFIX)[va_data->variable[i].unit_idx]);
                    }
                }
                printf("\n\r");
            }
            printf("\n\r");
        }
    }

    /* Update the Green LED state */
    if (breathing_counter == 0)
    {
        led_pwm_set_brightness(LED_PWM_BLUE_LED, LED_PWM_MAX_BRIGHTNESS);
        led_pwm_on(LED_PWM_BLUE_LED);
    }
    else
    {
        /* Increment twice for faster breathing */
        breathing_counter++;
        breathing_counter++;

        if (breathing_counter >= (2*LED_PWM_MAX_BRIGHTNESS))
        {
            breathing_counter = LED_PWM_MIN_BRIGHTNESS;
        }

        led_pwm_set_brightness(LED_PWM_BLUE_LED, abs(((int) (breathing_counter - LED_PWM_MAX_BRIGHTNESS))));
    }
}

/*******************************************************************************
 * Function Name: run_voice_assistant_process
 *******************************************************************************
 * Summary:
 * Run the voice assistant process and print any information in the terminal.
 *  
 * Parameters:
 *  audio_frame: pointer to the audio data frame
 *
 * Return:
 *  void
 *
 *******************************************************************************/
static void run_voice_assistant_process(int16_t *audio_frame)
{
    va_rslt_t va_result;
    va_data_t va_data;
    va_event_t va_event;

#ifdef SHOW_MCPS
    profiler_start();
#endif    
    /* Process the audio data */
    va_result = voice_assistant_process(audio_frame, &va_event, &va_data);
#ifdef SHOW_MCPS
    profiler_stop();
    print_mcps();
#endif

    /* Print the status of the voice assistant */
    print_voice_assistant_status(va_result, va_event, &va_data);

    #ifdef USE_LED_DEMO
        /* Change the status of the LED if a command was detected */
        if (va_event == VA_EVENT_CMD_DETECTED)
        {
            led_demo(va_data.intent_index, va_data.variable[0].value);
        }
    #endif
}

/*******************************************************************************
 * Function Name: voice_assistant_task
 *******************************************************************************
 * Summary:
 * This is the FreeRTOS task to execute the DEEPCRAFT voice assistant routines.
 *
 * Parameters:
 *  void * arg
 *
 * Return:
 *  void
 *
 *******************************************************************************/
void voice_assistant_task(void * arg)
{
    int16_t *audio_frame;
    va_rslt_t va_result;
#ifdef USE_AUDIO_ENHANCEMENT
    ae_rslt_t ae_result;
#endif /* USE_AUDIO_ENHANCEMENT */    
    
    /* Initialize the PDM microphone */
    pdm_mic_init();

    // Initialize the profiler to print MCPS
#ifdef SHOW_MCPS
    profiler_init();
#endif /* SHOW_MCPS */   

    /* Initialize the LED PWM driver */
    led_pwm_init();

    /* Initialize the voice assistant */
    va_result = voice_assistant_init(RUNNING_MODE);

    if (va_result != VA_RSLT_SUCCESS)
    {
        printf("Error initializing the voice assistant. Error code=%d\r\n", va_result);
        handle_error();
    }
    else
    {
        printf("Voice Assistant initialized!\r\n\r\n");
    }

    /* Set the initial breathing counter value */
    if (RUNNING_MODE == VA_MODE_CMD_ONLY)
    {
        breathing_counter = LED_PWM_MIN_BRIGHTNESS;
    }
    else
    {
        breathing_counter = 0;
    }

#ifdef USE_LED_DEMO
    printf("Wake word: Okay Infineon \n\n\r");
    printf("Example: Okay Infineon <switch on the light>\n\n\r");
    printf("Commands: \r\n");
    printf("1. Turn/Switch on the light \r\n");
    printf("2. Turn/Switch off the light \r\n");
    printf("3. Enable/Disable the light \r\n");
    printf("4. Increase/Decrease the brightness \r\n");
    printf("5. Make the light brighter/dimmer \r\n");
    printf("6. Set/Adjust the brightness to <numbers 1 to 10> \r\n");
    printf("7. Dim light to <numbers 1 to 10> \r\n");
    printf("8. Flip/Toggle the light \r\n");
    printf("9. Change the light state \r\n\r\n");
#else
    /* Print the instructions */
    if ((RUNNING_MODE == VA_MODE_WW_SINGLE_CMD) || (RUNNING_MODE == VA_MODE_WW_MULTI_CMD)) 
    {
        printf("\n\rSay the wake-word \"%s\" followed by a command.\n\r\n\r", 
               MTB_WWD_NLU_CONFIG_WAKE_WORD_STR(PROJECT_PREFIX)[0]);
    } 
    else if (RUNNING_MODE == VA_MODE_WW_ONLY)
    {
        printf("\n\rSay the wake-word \"%s\".\n\r\n\r", 
               MTB_WWD_NLU_CONFIG_WAKE_WORD_STR(PROJECT_PREFIX)[0]);
    } 
    else if (RUNNING_MODE == VA_MODE_CMD_ONLY)
    {
        printf("\n\rSay a command.\n\r");
    }
#endif /* USE_LED_DEMO */

    /* Print the behavior of the Blue LED */
    printf("Note:\r\n");
    printf("a. BLUE User LED will be solid ON --> indicating waiting for wake word \r\n");
    if (RUNNING_MODE != VA_MODE_WW_ONLY)
    {
        printf("b. On successful wake word detection BLUE User LED will start breathing, indicating waiting for command\r\n");
        printf("c. After successful command detection and execution BLUE User LED will be solid again indicating step (a) \r\n");
        printf("d. In case of timeout or silence after wake word detection BLUE User LED will be solid again indicating step (a) \r\n");
    }
    printf("\n\r");

    for (;;)
    {
        /* Get audio data */
        pdm_mic_get_data(&audio_frame);

        /* Read the user button state */
        if (true == check_button_pressed())
        {
            printf("Push to Talk Button detected! Say a command!\r\n\r\n");
            voice_assistant_change_state(VA_RUN_CMD);
        }
        
#ifdef USE_AUDIO_ENHANCEMENT
        /* Apply the audio enhancement if AFE is enabled */
        ae_result = audio_enhancement_feed_input(audio_frame, NULL);
        if (ae_result == AE_RSLT_LICENSE_ERROR)
        {
            printf("ERROR! Audio Enhancement license expired!\r\n");
            handle_error();
        }
#else   

        /* If Audio Enhancement is not used, run voice-assistant 
         * directly with the microphone data */
        run_voice_assistant_process(audio_frame);

#endif  /* USE_AUDIO_ENHANCEMENT */       

    }  
}

/*****************************************************************************
 * Function Name: main
 ******************************************************************************
 * Summary:
 * This is the main function for CM55 non-secure application. 
 *    1. It initializes the device and board peripherals.
 *    3. It creates the FreeRTOS application task 
 *    4. It starts the RTOS task scheduler.
 *
 * Parameters:
 *  void
 *
 * Return:
 *  int
 *
 *****************************************************************************/
int main(void)
{
    cy_rslt_t result;

    /* Initialize the device and board peripherals */
    result = cybsp_init();

    /* Board init failed. Stop program execution */
    if (CY_RSLT_SUCCESS != result)
    {
        CY_ASSERT(0);
    }

    /* Enable global interrupts */
    __enable_irq();

    /* Initialize retarget-io middleware */
    init_retarget_io();

    printf("\x1b[2J\x1b[;H");

    printf("******************************************** \r\n"
           "PSOC Edge MCU: Voice Assistant Demo          \r\n"
           "******************************************** \r\n\n");

    setup_tickless_idle_timer();

    /* If AFE is used, intialize the audio enhancement */
#ifdef USE_AUDIO_ENHANCEMENT
    ae_rslt_t ae_result;

    ae_result = audio_enhancement_init(NUM_AUDIO_CHANNELS);
    if (ae_result != AE_RSLT_SUCCESS)
    {
        printf("Error initializing the audio enhancement. Error code=%d\r\n", ae_result);
        handle_error();
    }
    else
    {
        printf("Audio Enhancement initialized!\r\n");
    }
#endif /* USE_AUDIO_ENHANCEMENT */

    /* Create the FreeRTOS Task */
    result = xTaskCreate(voice_assistant_task, 
                         VOICE_ASSISTANT_TASK_NAME, 
                         VOICE_ASSISTANT_TASK_STACK_SIZE, NULL, 
                         VOICE_ASSISTANT_TASK_PRIORITY, NULL);

    if( pdPASS == result )
    {
        /* Start the RTOS Scheduler */
        vTaskStartScheduler();
    }

    return 0;
}

#ifdef USE_AUDIO_ENHANCEMENT
/*******************************************************************************
 * Function Name: audio_enhancement_process_output
 *******************************************************************************
 * Summary:
 * Strong implementation to process the audio enhancement output.
 *
 * Parameters:
 *  output_buffer: pointer to the output audio data buffer.
 *
 * Return:
 *  void
 *
 *******************************************************************************/
void audio_enhancement_process_output(ae_buffer_info_t *output_buffer)
{
    /* Use the output data from the audio enhancement with the voice-assistant */
    run_voice_assistant_process(output_buffer->output_buf);
}
#endif

/* [] END OF FILE */
